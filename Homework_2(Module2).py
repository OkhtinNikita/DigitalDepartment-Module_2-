# #Cуммирование значений в массиве
import numpy as np

# rng = np.random.default_rng(1) # 
# s = rng.random(50)

# print(s)

# print(sum(s)) # Питоновская сумма
# print(np.sum(s)) # Сумма нампи, она быстрее на больших объемах и может считать многомерные массивы

# a = np.array([
#     [1, 2, 3],
#     [2, 3, 4]
# ])
# print(sum(a)) # выдаст [3 5 7]
# print(np.sum(a)) # 15
# print(np.sum(a, axis = 0)) # 0 - строки, выдаст [3 5 7]
# print(np.sum(a, axis = 1)) # 1 - столбцы, [6 9]

# print(np.min(a)) # 1
# print(np.min(a, axis = 0)) # 0 - строки, выдаст [1 2 3]
# print(np.min(a, axis = 1)) # 1 - столбцы, [1 2]

# # Альтернаятивная запись
# print(a.min(0))
# print(a.min(1))

# # В МЛ лучше использовать :
# print(np.nanmin(a))
# print(np.nanmin(a, axis = 0))
# print(np.nanmin(a, axis = 1))
# NaN - Not a Number - не выдаст ошибку если в массиве будет NaN


# Транслирование (broadcasting)
# набор правил, которые позволяют осуществять бинарные операции с массивами разных форм и рамеров 

# a = np.array([0, 1 ,2])
# b = np.array([5, 5, 5])

# print(a + b) # [5 6 7]
# print(a + 5) # [5 6 7] - мы не прибавляем к каждому элементу 5, у нас пятерка в процессе транслирования становится не 5, а массивом [5, 5, 5]. Она подстраивается под
# #размер массива а. 
# # Оно может быть распространено и на многомерные массивы
# a = np.array([
#     [0, 1, 2],
#     [5, 6, 7]
# ])
# print(a + 5)

# a = np.array([0, 1 ,2])
# b = np.array([[0], [1], [2]]) # Столбец
# Получилось [[0, 1, 2], [1, 2, 3], [2, 3, 4]] - 3х3

#Правило 1: Если размерности массивов разные, то форма массива с меньшей размерностью дополняется 1 с левой стороны
# a = np.array([0, 1 ,2], [3, 4, 5])
# b = np.array([5])

# # print(a.ndim, a.shape) #ndim - измерения, тут 2, shape - размер, тут (2, 3)
# # print(b.ndim, b.shape) #ndim - измерения, тут 1, shape - размер, тут (1,)
# # #По 1 правилу b.ndim 1 -> 2, shape (1,) -> (1, 1)

# # #Правило 2: если формы массивов не совпадают (shape) в каком-то измерении, то, если у массива форма = 1, от он растягивается до соответствия формы 2 массива
# # # b (1, 1) -> (2, 3)
# # #Правило 3: если в каком-либо измерении размеры массивов отличаются и ни один из них не равен 1, то генериуется ошибка
# # print(a + b)

# a = np.ones((2, 3)) #[[1. 1. 1.]
# #                    [1. 1. 1.]]
# b = np.arange(3) # [0 1 2]
# print(a)
# print(b)
# print(a.ndim, a.shape) # 2, (2,3)
# print(b.ndim, b.shape) # 1, (3,)

# # (2,3)   (2, 3)   (2, 3)
# # (3,) -> (1,3) -> (2, 3)
# c = a + b
# print(c, c.shape) # [[1. 2. 3.] [1. 2. 3.]] (2, 3)

# a = np.arange(3).reshape((3, 1))
# b = np.arange(3)
# print(a) #столбец 0 1 2 
# print(b) # строка 0 1 2 
# print(a.ndim, a.shape) # 2, (3, 1)
# print(b.ndim, b.shape) # 1, (3,)

# # (3, 1)   (3, 1) -> (3, 3)
# # (3,) ->  (1, 3) -> (3, 3)

# print((a + b), (a + b).shape) # [[0 1 2]
# #                               [1 2 3]
# #                               [2 3 4]] (3, 3)

# # [0 0 0]        [0 1 2]
# # [1 1 1]   +    [0 1 2]
# # [2 2 2]        [0 1 2]

# a = np.ones((3, 2))
# b = np.arange(3)
# # 2 (3, 2)  (3, 2)  (3, 2)
# # 1 (3,)    (1, 3)  (3, 3)

# # c = a + b # ошибка ValueError

## Задание 1. Что надо изменить в последнем примере, чтобы он заработал без ошибок (транслирование)?

# Нужно сделать размер массива b таким, чтобы он был совместим с а, то есть добавить, по сути, измерение
a = np.ones((3,2))
b = np.arange(3)
print(a)
print(b)

print(a.ndim, a.shape)
print(b.ndim, b.shape)
print()

b = b[:, np.newaxis]
print(b)
c = a + b
print(c, c.shape)

# Вывод:
# [[1. 1.]
#  [1. 1.]
#  [1. 1.]]
# [0 1 2]
# 2 (3, 2)
# 1 (3,)

# [[0]
#  [1]
#  [2]]
# [[1. 1.]
#  [2. 2.]
#  [3. 3.]] (3, 2)

# x = np.array([
#     [1, 2, 3, 4, 5, 6, 7, 8, 9],
#     [9, 8, 7, 6, 5, 4, 3, 2, 1]
# ])

# xmean0 = x.mean(0) # [5. 5. 5. ...]
# # Отцентрирование (чтобы по центру 0)
# xcenter0 = x - xmean0 # [-4 -3 -2 -1 0 1 2 3 4]

# xmean1 = x.mean(1) # [5. 5.]

# # xcenter1 = x - xmean1 не сработает тк разные размеры, чтобы обойти это нам надо повернуть массив, те превратить в столбец
# # xmean1 = xmean1[:, np.newaxis] 

# # xcenter1 = x - xmean1 # [-4 -3 -2 -1 0 1 2 3 4]


# # # чтобы сделать типа х - одна координата, у - вторая, надо у повернуть
# # x = np.linspace(0, 5, 50)
# # y = np.linspace(0, 5, 50)[:, np.newaxis]

# # z = np.sin(x) ** 3 + np.cos(20 + y * x) * np.sin(y) #z.shape (50, 50)

# #import matplotlib.pyplot as plt
# # plt.imshow(z)
# # plt.colorbar()
# # plt.show()

# x = np.array([1, 2, 3, 4, 5])
# y = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])

# print(x < 3) # [ True  True False False False]

# print(np.less(x, 3))# [ True  True False False False]

# print(np.sum(x < 3)) # 2 - тк количество (True = 1, False 0)

# print(np.sum(y < 4)) # 3, но эл-ты массива дб одинакового shape
# print(np.sum(y < 4, axis = 0)) # [1 1 1 0 0]
# print(np.sum(y < 4, axis = 1)) # [3 0] 

## Пример для y. Вычислить количество элементов (по обоим размерностям), значения которых больше 3 и меньше 9

y = np.array(([1,2,3,4,5], [6,7,8,9,10]))

print(np.sum((y > 3) & (y < 9))) # 5


# x = np.array([1, 2, 3, 4, 5])
# print(x[x < 3])

# # Векторизация индекса

# x = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
# index = [1, 5, 7]

# print(x[index]) # [2 6 8]

# index = [[1, 5, 7], [2, 4, 8]]
# print(x[index]) #[[2 6 8]
#                 [3 5 9]]
# Результат отражает не исходный массив, а массив index

# x = np.arange(12).reshape(3, 4)

# print(x) # [[ 0  1  2  3]
#  #          [ 4  5  6  7]
#  #          [ 8  9 10 11]]
# print(x[2]) # [ 8  9 10 11]

# print(x[2, [2, 0, 1]]) # берем 2 строку, из нее 2 эл-т, 0 эл-т и 1 эл-т
# # #                       [10  8 9]
# # print(x[1:, [2, 0, 1]]) # [[ 6  4  5]
# # #                        [10  8  9]]

# # Мы можем изменять эл-ты с помощью этой векторизации
# x = np.arange(10)
# i = np.array([2, 1, 8, 4])
# print(x) # [0 1 2 3 4 5 6 7 8 9]
# x[i] = 999
# print(x) # [  0 999 999   3 999   5   6   7 999   9]

# # Сортироввка

# x = [3, 2, 4, 5, 1, 5, 7, 8, 9, 5, 3]

# print(sorted(x))
# print(np.sort(x))
# print(x.sort())


# #Структурированные массивы

# data = np.zeros(4, dtype = {
#     'names' : (
#         'name', 'age'
#     ),
#     'formats' : (
#         'U10', 'i4'
#     )
# })

# print(data.dtype) # [('name', '<U10'), ('age', '<i4')] < - обратный порядок байт > - прямой порядок байт

# name = ['name1', 'name2', 'name3', 'name4']
# age = [20, 30, 40, 10]

# #Если у нас есть 2 массива одинакового размера то мы можем использовать их вместе

# data['name'] = name
# data['age'] = age

# print(data) #   [('name', '<U10'), ('age', '<i4')]
# #               [('name1', 20) ('name2', 30) ('name3', 40) ('name4', 10)]

# print(data['age'] > 20) # [False  True  True False]

# print(data[data['age'] > 20]) # [('name2', 30) ('name3', 40)]


# # Массивы записей

# # По сути они отличаются только тем, что к их элементам можно обращаться не только как к ключам, а можно и по атрибутам (по сути по индексам)

# data_rec =  data.view(np.recarray)
# print(data_rec)  # [('name1', 20) ('name2', 30) ('name3', 40) ('name4', 10)]

# print(data_rec[0]) # Можно обращатсья по индексам, в предыдущем ( структуриованные массивы) - не можем
# print(data_rec[-1].name) # name4
 